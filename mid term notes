시스템 프로그래밍 중간 요약

<1주차>
* 변수: 데이터를 저장하는 공간
* 변수의 메모리 주소값을 얻는 번: 주소 연산자 &
* 포인터 변수: 다른 변수의 메모리 주소값을 저장하는 변수
* 포인터 변수를 이용해서 현재 기억하고 있는 그 주소의 원래 변수의 값을 읽거나 쓸 수 있다
* 간접 지정 연산자 * : 포인터 변수가 현재 저장하고 있는 주소값의 변수 또는 가리키는 변수의 값을 읽거나 쓸때 사용
* 포인터가 필요한 이유: c는 기본적으로 call by vaule라서 다른 함수의 값을 바꿀 수 없다. 포인터 변수를 이용해서 다른 함수의 값을 마음대로 바꿀 수 있다
* 함수 내에서 포인터 변수를 통해서 간접적으로 변수의 값을 바꿔줄 수 있다


<2주차>
* 지역 변수는 함수를 호출하면서 메모리에 생기고, 함수가 끝나면 access할 수 없음
* 메모리 영역
-코드 영역: 내가 짠 프로그램이 올라가는 영역
-데이터 영역: 전역 변수, 상수
-스택 영역: 지역 변수
-힙 영역: 동적 메모리 할당

* 구조체 포인터: 포인터 변수의 크기는 8byte -> 주소를 기억하는데 8byte이면 충분
struct student *p = &s1; //구조체 s1의 주소값을 저장하는 구조체 포인터
(*p).id=30; //구조체 포인터를 이용해서 p가 가리키는 구조체의 값을 변경
p->id=30; //구조체 포인터에만 쓸 수 있음
* 연결리스트: 자기 참조 구조체를 활용
struct StudentNode{
  char a;
  int b;
  struct StudentNode * next; //자기 참조 구조체
}
NULL은 0번지 = 아무것도 가리키고 있지 않다

* 함수 포인터: 함수의 주소를 기억하는 변수
* 함수 이름: 그 함수가 있는 프로그램 코드의 위치
int (*fp)(int, int); //함수 포인터의 선언
이름: fp
type: int(*)(int, int)
parameter가 int 2개인 함수
return값은 int 하나인 함수
다른 함수의 주소를 기억
다른 함수를 기억해서 그 함수를 대신해서 호출할 수 있음
어떤 때는 add함수를 호출하고 다른 때는 multi함수를 호출 -> 다형성
모양은 같은데 실제로 호출되는 함수는 다르다 -> 다형성을 함수 포인터로 흉내낼 수 있다










